
CREATE PROCEDURE sp_who
AS
    SELECT * from slabs
EXEC sp_who;
GO




@model PartyInvites.Models.GuestResponse

@{
    Layout = null;
}

<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>RsvpForm</title>
</head>
<body>
    @using (Html.BeginForm())
    {
        <p>Ваше имя: @Html.TextBoxFor(x => x.Name)</p>
        <p>Ваш email: @Html.TextBoxFor(x => x.Email)</p>
        <p>Ваш телефон: @Html.TextBoxFor(x => x.Phone)</p>
        <p>Вы придете?
            @Html.DropDownListFor(x => x.WillAttend, new[] {
                new SelectListItem() { Text = "Да, конечно я буду", Value = Boolean.TrueString},
                new SelectListItem() { Text = "Нет, я не смогу", Value = Boolean.FalseString}
            })
        </p>
        <input type="submit" value="Отправить форму RSVP" />
    }
</body>
</html>


---------------------------
Для каждого свойства класса модели GuestResponse мы используем вспомогательный метод HTML, чтобы визуализировать подходящий элемент управления HTML типа input. Эти методы позволяют с помощью лямбда-выражения выбрать свойство, с которым связан элемент input, как показано в следующей строке:

@Html.TextBoxFor(x => x.Email)
Вспомогательный метод HTML по имени TextBoxFor генерирует HTML-разметку для элемента input, устанавливает параметр type в text, а атрибуты id и name - в Email (имя выбранного свойства класса предметной области):

<input id="Email" name="Email" type="text" value="" />
Это удобное средство работает, потому что представление RsvpForm является строго типизированным, а инфраструктуре MVC было указано, что GuestResponse - тип, который нужно визуализировать с помощью этого представления. Это снабжает вспомогательные методы HTML информацией, которая им необходима для выяснения того, из какого типа данных должны быть прочитаны свойства через выражение @model.

Альтернативой применению лямбда-выражений является ссылка на имя свойства типа модели как на строку:

@Html.TextBox("Email")
Подход с использованием лямбда-выражения предотвращает неправильный ввод имени свойства типа модели, т.к. среда Visual Studio активизирует средство IntelliSense, позволяя выбрать свойство автоматически:

Использование средства IntelliSense среды Visual Studio для лямбда-выражений внутри вспомогательных методов HTML
Еще одним удобным вспомогательным методом является Html.BeginForm(), который генерирует HTML-элемент form, сконфигурированный на выполнение обратной отправки методу действия. Поскольку никакие аргументы вспомогательному методу не передаются, он предполагает, что требуется выполнить обратную отправку по тому же самому URL, из которого запрашивался HTML-документ. Изящный трюк заключается в том, чтобы поместить этот метод внутрь C#-оператора using, как показано ниже:

@using (Html.BeginForm())
{
	// сюда помещается содержимое формы...
}
Обычно при таком применении оператор using гарантирует освобождение объекта, когда он покидает область действия. Такое использование распространено, например, для подключений к базам данных, чтобы гарантировать их закрытие немедленно по завершении запроса. (Это применение ключевого слова using отличается от той его разновидности, которая включает классы из пространства имен в область действия какого-то класса.)

Вместо освобождения объекта вспомогательный метод Html.BeginForm закрывает HTML-элемент form, когда тот покидает область действия. Это означает, что вспомогательный метод Html.BeginForm создает обе части элемента формы:

<form action="/Home/RsvpForm" method="post">
	// ... содержимое формы
</form>
Не беспокойтесь, если не знакомы с удалением объектов C#. В данном случае задача заключается в том, чтобы продемонстрировать создание формы с помощью вспомогательного метода HTML.





<!-- tile Y line  /--> 
       <line id="L2"  ng-repeat="m in ratio" ng-if="m*selectedTile.yLen/10 <= heightRect" 
		x1="{{xRect}}" 		  y1="{{yRect+m*selectedTile.yLen/10}}"
                x2="{{xRect+widthRect}}"  y2="{{yRect+m*selectedTile.yLen/10}}">	</line>

<!-- tile X line  /--> 
       <line id="L2"  ng-repeat="m in ratio" ng-if="m*selectedTile.xLen/10 <= widthRect" 
		x1="{{xRect+m*selectedTile.xLen/10}}"  y1="{{yRect}}"
                x2="{{xRect+m*selectedTile.xLen/10}}"  y2="{{yRect+heightRect}}">	</line>


  line(xKr[n+1]/10-3,yKr[m]*0.08,xKr[n+1]/10-3,yKr[m-1]*0.08);
  line(xKr[n+1]/10,yKr[m]*0.08+2,xKr[n+1]/10-6,yKr[m]*0.08-2


for (n=xNr; n > 0; n--) { xKr[n] = xKr[n+1]-xSize;
     if((F!=4)&(prior==prI)) line(xKr[n]/10,I*2+v+1,xKr[n]/10,J*2+v-1);
    }   // for n      


xKr[xNr+1] = g*10+xRigh*10;